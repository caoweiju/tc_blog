---
title: 前端需要了解的redux中间件机制和简单的实现原理
date: 2019-09-30 15:37:43
tags:
---

## redux的中间件
>It provides a third-party extension point between dispatching an action, and the moment it reaches the reducer.

这是 redux 作者 Dan 对 middleware 的描述，middleware 提供了一个分类处理 action 的机会，在 middleware 中你可以检阅每一个流过的 action，挑选出特定类型的 action 进行相应操作，给你一次改变 action 的机会。

### redux使用中间件机制的动机
redux是一个单向数据流库， 下图是redux中一个简单的同步单向数据流动的场景，点击 button 后，在回调中 dispatch 一个 action，reducer 收到 action 后，更新 state 并通知 view 重新渲染。单向数据流，

![redux](./../../imgs/redux.jpg)

在开发者使用的时候并没有什么问题，如果在复杂场景中，我们再dispatch 一个 action的时候需要去服务端获取数据，并且需要打印请求发起reque记录和请求结果response记录，如果只是修改某一次的dispatch，那么其他我们直接修改就好了，但是如果每一次的dispatch都需要被记录呢？如果还是在原来的代码中添加的话，那么将会变得不可控，意于是redux 作者 Dan引入了 middleware，

![redux](./../../imgs/redux-mid.jpg)

这种模式就是可以组合的，自由插拔的插件机制，借鉴于KOA的中间件思想，使用 middleware 来增强 dispatch ，完成我们需要的一些功能。

## 简单实现思路
为了能够实现上述的中间件机制，我们需要清楚整个过程中发生了什么，以及我们需要实现什么，

正常的dispatch一个action的时候，我们认为是如下行为：
````
----- dispatch(action)||dispatch(createrAction()) -----
````
引入了middleware之后我们就需要去实现如下行为：`applyMiddleware(MidA, MidB, MidC, MidD)`
````
--->MidA
        --->MidB
                --->MidC
                        --->MidD
                                <-->dispatch(action)||dispatch(createrAction())
                        <---MidD
                <---MidC
        <---MidB
<---MidA
````
可以看到是会顺序执行Middleware，可以看到第一个中间件MidA执行中会调用MidB，而MidB运行中调用了MidC，而MidC运行中调用了MidD，MidD执行后是最后一个中间件，所以会执行dispatch的原来内容，完成后返回到MidD的执行上下文，而MidD执行完成后又会回到MidC上下文，在MidC执行完成后，会返回到调用MidC的MidB执行上下文中，最后回到最开始调用的中间件MidA中，执行完成MidA后整个机制就完成了；

为了实现这种效果，如下细节需要注意：
1. 我们需要规定一下这些中间件的格式，
2. 首先中间件必须是一个函数方便调用，`() => {}`
3. 其次函数中必须有一个参数用来调用下一个中间件函数，还需要这个dispatch这个方法需要的参数action，或者说是中间件整个机制的上下文：
    ````js
    const MidA = (action, next) => { 
        // 做一些MidA插件需要干的事 比如添加 log等
        log('start log')
        next(action); // 调用下一个中间件
        log('end log')
    }
    ````

有了上面的基础了解，我们知道了最后整体的实现后的结果就是这样的：
````js
const MidA = (action, next) => { 
    // 做一些MidA插件需要干的事 比如添加 log等
    log('start log AAAA', action)
    next(action); // 调用下一个中间件
    log('end log AAAA', action)
}
const MidB = (action, next) => { 
    // 做一些MidA插件需要干的事 比如添加 log等
    log('start log BBBB', action)
    next(action); // 调用下一个中间件
    log('end log BBBB', action)
}
const MidC = (action, next) => { 
    // 做一些MidA插件需要干的事 比如添加 log等
    log('start log CCCC', action)
    next(action); // 调用下一个中间件
    log('end log CCCC', action)
}

const midStack = applyMiddleware(MidA, MidB, MidC);
// 这里applyMiddleware需要得到的函数 midStack 是这样的函数：
midStack = (action) => {
    MidA(action, (action) => {
        MidB(action, (action) => {
            MidC(action, (action) => {
                dispatch(action);
            })
        });
    })
};
// 通过 midStack(action) 可以达到上面的中间件机制的目的。
````
为了实现上面的这种嵌套格式(特别是在中间件较多的时候写起来很别扭)，需要封装一个applyMiddleware函数；
````js
const applyMiddleware = (...mids) => {
    const [MidA, MidB, MidC] = mids;
    if(mids.length === 1) {
        return (action) =>  MidA(action, (action) => {
                dispatch(action);
            });
    }
    const midStack = mids.reduce((preMid, nextMid) => {
        return (action, next) => {

        }
    });
    return midStack;
}
````


## redux中间件机制源码

